#pragma once
#include <memory>
#include <omp.h>
#include <span>
#include <trajan/core/atom.h>
#include <trajan/core/linear_algebra.h>
#include <trajan/core/unit_cell.h>
#include <unordered_map>
#include <vector>

namespace trajan::core {

struct CellIndex {
  size_t a, b, c;
};

class Cell {
public:
  void add_atom(Atom &atom);
  const std::vector<Atom> &get_atoms() const { return m_atoms; }
  void clear() { m_atoms.clear(); }

private:
  std::vector<Atom> m_atoms;
  CellIndex m_index;
  friend class CellList;
};

struct CellListParameters {
  const size_t num_ghosts;
  const size_t a, b, c;
  const size_t total_cells;
  const size_t total_a, total_b, total_c;
  const size_t a_upper, b_upper, c_upper;
  const size_t a_end, b_end, c_end;
  CellListParameters(size_t a, size_t b, size_t c, size_t num_ghosts)
      : num_ghosts(num_ghosts), a(a), b(b), c(c), total_a(a + 2 * num_ghosts),
        total_b(b + 2 * num_ghosts), total_c(c + 2 * num_ghosts),
        total_cells(a + 2 * num_ghosts * b + 2 * num_ghosts * c +
                    2 * num_ghosts),
        a_end(a + num_ghosts), b_end(b + num_ghosts), c_end(c + num_ghosts),
        a_upper(a - num_ghosts), b_upper(b - num_ghosts),
        c_upper(c - num_ghosts) {}
};

struct CellIndexHash {
  std::size_t operator()(const CellIndex &idx) const {
    // Combine the three components into a single hash
    // Using bit shifts to combine the values while minimizing collisions
    return (static_cast<size_t>(idx.a) << 32) ^
           (static_cast<size_t>(idx.b) << 16) ^ static_cast<size_t>(idx.c);
  }
};

struct CellIndexEqual {
  bool operator()(const CellIndex &lhs, const CellIndex &rhs) const {
    return lhs.a == rhs.a && lhs.b == rhs.b && lhs.c == rhs.c;
  }
};

class CellList {
public:
  static constexpr size_t NUMGHOSTS = 2;
  static constexpr size_t NUMGHOSTSNEIGH =
      ((2 * NUMGHOSTS + 1) * (2 * NUMGHOSTS + 1) * (2 * NUMGHOSTS + 1) - 1) / 2;
  CellList(const UnitCell &unit_cell, double cutoff, int num_threads);
  void update(std::span<Atom> atoms);
  template <typename Func> void for_each_pair(Func &&func) const;

private:
  const UnitCell &m_unit_cell;
  const double m_cutoff, m_cutoffsq;
  const int m_num_threads;
  const CellListParameters m_params;
  std::unique_ptr<Cell[]> m_cells;

  std::unordered_map<size_t, std::array<size_t, NUMGHOSTSNEIGH>>
      m_neighbor_list;
  std::unordered_map<size_t, size_t> m_neighbor_counts;
  std::unordered_map<CellIndex, size_t, CellIndexHash, CellIndexEqual>
      m_coordinate_map;

  void build_coordinate_map();
  void build_neighbor_list();
  size_t get_index_from_coords(const CellIndex &coords) const;
  constexpr size_t get_cell_index(int a, int b, int c) const {
    return a * (m_params.total_b * m_params.total_c) + b * m_params.total_c + c;
  }
  const CellListParameters generate_cell_params(const UnitCell &unit_cell,
                                                double cutoff,
                                                const size_t num_ghosts) const;
  void initialise_cells();
  void clear_cells();
  // template <typename Func>
  // void process_cell(const Cell &center_cell, Func &&func) const;
  template <typename Func>
  void process_cell(size_t cell_idx, Func &&func) const;
};
// template <typename Func>
// void process_cell_pairs(const Cell &center_cell, int na, int nb, int nc,
//                         Func &&func) const;

// template <typename Func>
// void CellList::process_cell_pairs(const Cell &center_cell, int na, int nb,
//                                   int nc, Func &&func) const {
//   auto center_atoms = center_cell.get_atoms();
//   if (na == 0 && nb == 0 && nc == 0) {
//     // for same cell, only check i < j pairs
//     for (size_t i = 0; i < center_atoms.size(); ++i) {
//       const auto &atom1 = center_atoms[i];
//       for (size_t j = i + 1; j < center_atoms.size(); ++j) {
//         const auto &atom2 = center_atoms[j];
//         double rsq = atom1.square_distance(atom2);
//         if (rsq <= m_cutoffsq) {
//           func(atom1, atom2);
//         }
//       }
//     }
//     return;
//   }
//
//   // process forward direction to prevent double coutning
//   if (na < 0 || (na == 0 && nb < 0) || (na == 0 && nb == 0 && nc < 0)) {
//     return;
//   }
//   // if (na < 0 || nb < 0 || nc < 0) {
//   //   return;
//   // }
//   int neigh_a = center_cell.m_index.a + na;
//   int neigh_b = center_cell.m_index.b + nb;
//   int neigh_c = center_cell.m_index.c + nc;
//   const Cell &neighbor_cell = m_cells[neigh_a][neigh_b][neigh_c];
//
//   // process pairs between cells
//   auto neigh_atoms = neighbor_cell.get_atoms();
//   for (const Atom &atom1 : center_atoms) {
//     for (const Atom &atom2 : neigh_atoms) {
//       double rsq = atom1.square_distance(atom2);
//       if (rsq <= m_cutoffsq) {
//         func(atom1, atom2);
//       }
//     }
//   }
// }
//
// template <typename Func>
// void CellList::process_cell(const Cell &center_cell, Func &&func) const {
//   const int adj = m_params.num_ghosts;
//   for (int na = -adj; na <= adj; ++na) {
//     for (int nb = -adj; nb <= adj; ++nb) {
//       for (int nc = -adj; nc <= adj; ++nc) {
//         process_cell_pairs(center_cell, na, nb, nc, func);
//       }
//     }
//   }
// }
//
// template <typename Func> void CellList::for_each_pair(Func &&func) const {
//   // #pragma omp parallel for collapse(3) schedule(dynamic) if
//   (m_num_threads
//   >
//   // 1)
//   for (int a = m_params.num_ghosts; a < m_params.a_end; ++a) {
//     for (int b = m_params.num_ghosts; b < m_params.b_end; ++b) {
//       for (int c = m_params.num_ghosts; c < m_params.c_end; ++c) {
//         process_cell(m_cells[a][b][c], func);
//       }
//     }
//   }
// }
template <typename Func>
void CellList::process_cell(size_t cell_idx, Func &&func) const {
  const auto &center_cell = m_cells[cell_idx];
  const auto &center_atoms = center_cell.get_atoms();

  // Process atoms within the same cell
  for (size_t i = 0; i < center_atoms.size(); ++i) {
    const auto &atom1 = center_atoms[i];
    for (size_t j = i + 1; j < center_atoms.size(); ++j) {
      const auto &atom2 = center_atoms[j];
      double rsq = atom1.square_distance(atom2);
      if (rsq <= m_cutoffsq) {
        func(atom1, atom2);
      }
    }
  }

  // Process neighboring cells
  auto neighbor_it = m_neighbor_list.find(cell_idx);
  if (neighbor_it != m_neighbor_list.end()) {
    const auto &neighbor_indices = neighbor_it->second;
    const size_t num_neighbors = m_neighbor_counts.at(cell_idx);

    for (size_t i = 0; i < num_neighbors; ++i) {
      const auto &neighbor_cell = m_cells[neighbor_indices[i]];
      const auto &neighbor_atoms = neighbor_cell.get_atoms();

      for (const auto &atom1 : center_atoms) {
        for (const auto &atom2 : neighbor_atoms) {
          double rsq = atom1.square_distance(atom2);
          if (rsq <= m_cutoffsq) {
            func(atom1, atom2);
          }
        }
      }
    }
  }
}

template <typename Func> void CellList::for_each_pair(Func &&func) const {
  // #pragma omp parallel for schedule(dynamic) if (m_num_threads > 1)
  for (size_t idx = 0; idx < m_params.total_cells; ++idx) {
    process_cell(idx, func);
  }
}
}; // namespace trajan::core
#include <iostream>
#include <memory>
#include <omp.h>
#include <trajan/core/neigh.h>
namespace trajan::core {

void Cell::add_atom(Atom &atom) { m_atoms.push_back(atom); }

CellList::CellList(const UnitCell &unit_cell, double cutoff, int num_threads)
    : m_unit_cell(unit_cell), m_cutoff(cutoff), m_cutoffsq(cutoff * cutoff),
      m_num_threads(num_threads),
      m_params(generate_cell_params(unit_cell, cutoff, NUMGHOSTS)) {
  if (m_num_threads > 0) {
    omp_set_num_threads(m_num_threads);
  }
  m_cells = std::make_unique<Cell[]>(m_params.total_cells);
  // initialise_cells();
  build_coordinate_map();
  build_neighbor_list();
}

void CellList::build_coordinate_map() {
  m_coordinate_map.reserve(m_params.total_cells); // Preallocate for performance
  // for (size_t idx = 0; idx < m_params.total_cells; ++idx) {
  // }
  for (size_t a = 0; a < m_params.total_a; ++a) {
    for (size_t b = 0; b < m_params.total_b; ++b) {
      for (size_t c = 0; c < m_params.total_c; ++c) {
        CellIndex idx{a, b, c};
        size_t linear_idx = get_cell_index(a, b, c);
        m_coordinate_map[idx] = linear_idx;
        m_cells[linear_idx].m_index = idx;
      }
    }
  }
}

void CellList::build_neighbor_list() {
  const int adj = m_params.num_ghosts;

  for (int a = m_params.num_ghosts; a < m_params.a_end; ++a) {
    for (int b = m_params.num_ghosts; b < m_params.b_end; ++b) {
      for (int c = m_params.num_ghosts; c < m_params.c_end; ++c) {
        size_t center_idx = get_cell_index(a, b, c);
        size_t neighbor_count = 0;
        auto &neighbors = m_neighbor_list[center_idx];

        for (int na = -adj; na <= adj; ++na) {
          for (int nb = -adj; nb <= adj; ++nb) {
            for (int nc = -adj; nc <= adj; ++nc) {
              // Skip self and backward directions to prevent double counting
              if (na < 0 || (na == 0 && nb < 0) ||
                  (na == 0 && nb == 0 && nc <= 0)) {
                continue;
              }

              int neigh_a = a + na;
              int neigh_b = b + nb;
              int neigh_c = c + nc;

              size_t neighbor_idx = get_cell_index(neigh_a, neigh_b, neigh_c);
              neighbors[neighbor_count++] = neighbor_idx;
            }
          }
        }

        m_neighbor_counts[center_idx] = neighbor_count;
      }
    }
  }
}

size_t CellList::get_index_from_coords(const CellIndex &coords) const {
  auto it = m_coordinate_map.find(coords);
  if (it != m_coordinate_map.end()) {
    return it->second;
  }
  // Handle error case - could throw exception or return sentinel value
  throw std::out_of_range("Invalid cell coordinates");
}

const CellListParameters
CellList::generate_cell_params(const UnitCell &unit_cell, double cutoff,
                               const size_t num_ghosts) const {
  return CellListParameters(
      static_cast<int>(
          std::floor(unit_cell.a_vector().norm() / (cutoff / num_ghosts))),
      static_cast<int>(
          std::floor(unit_cell.b_vector().norm() / (cutoff / num_ghosts))),
      static_cast<int>(
          std::floor(unit_cell.c_vector().norm() / (cutoff / num_ghosts))),
      num_ghosts);
}

// void CellList::initialise_cells() {
//   // m_params = calculate_cell_counts(NUMGHOSTS);
//   m_cells.resize(m_params.total_a);
//   for (auto &plane : m_cells) {
//     plane.resize(m_params.total_b);
//     for (auto &line : plane) {
//       line.resize(m_params.total_c);
//     }
//   }
//   for (int a = 0; a < m_params.total_a; ++a) {
//     for (int b = 0; b < m_params.total_b; ++b) {
//       for (int c = 0; c < m_params.total_c; ++c) {
//         m_cells[a][b][c].m_index = CellIndex{a, b, c};
//       }
//     }
//   }
// }

// void CellList::clear_cells() {
//   // #pragma omp parallel for collapse(3) schedule(static)
//   for (size_t a = 0; a < m_params.total_a; ++a) {
//     for (size_t b = 0; b < m_params.total_b; ++b) {
//       for (size_t c = 0; c < m_params.total_c; ++c) {
//         m_cells[a][b][c].m_atoms.clear();
//       }
//     }
//   }
// }

void CellList::clear_cells() {
  // #pragma omp parallel for schedule(static) if (m_num_threads > 1)
  for (size_t idx = 0; idx < m_params.total_cells; ++idx) {
    m_cells[idx].clear();
  }
}

// void CellList::update(std::span<Atom> atoms) {
//   clear_cells();
//   // #pragma omp parallel for schedule(dynamic)
//   for (Atom &atom : atoms) {
//     Vec3 frac_pos = m_unit_cell.to_fractional(atom.position());
//     // frac_pos = frac_pos.array() - frac_pos.array().floor();
//     int ind_a = static_cast<int>(frac_pos.x() * m_params.a);
//     int ind_b = static_cast<int>(frac_pos.y() * m_params.b);
//     int ind_c = static_cast<int>(frac_pos.z() * m_params.c);
//     m_cells[ind_a + m_params.num_ghosts][ind_b + m_params.num_ghosts]
//            [ind_c + m_params.num_ghosts]
//                .add_atom(atom);
//
//     // do the ghosts as well
//     if (ind_a >= m_params.num_ghosts && ind_a < m_params.a_upper &&
//         ind_b >= m_params.num_ghosts && ind_b < m_params.b_upper &&
//         ind_c >= m_params.num_ghosts && ind_c < m_params.c_upper) {
//       continue;
//     }
//     int a = (ind_a < m_params.num_ghosts)
//                 ? 1
//                 : (ind_a >= m_params.a_upper ? -1 : 0);
//     int b = (ind_b < m_params.num_ghosts)
//                 ? 1
//                 : (ind_b >= m_params.b_upper ? -1 : 0);
//     int c = (ind_c < m_params.num_ghosts)
//                 ? 1
//                 : (ind_c >= m_params.c_upper ? -1 : 0);
//
//     for (int ia = 0; ia <= std::abs(a); ia++) {
//       for (int ib = 0; ib <= std::abs(b); ib++) {
//         for (int ic = 0; ic <= std::abs(c); ic++) {
//           if (ia == 0 && ib == 0 && ic == 0) {
//             continue;
//           }
//           int a_shift = ia * a, b_shift = ib * b, c_shift = ic * c;
//           Vec3 shift = m_unit_cell.direct() * Vec3(a_shift, b_shift,
//           c_shift); m_cells[ind_a + a_shift * m_params.a +
//           m_params.num_ghosts]
//                  [ind_b + b_shift * m_params.b + m_params.num_ghosts]
//                  [ind_c + c_shift * m_params.c + m_params.num_ghosts]
//                      .m_atoms.emplace_back(atom.create_ghost(shift));
//         }
//       }
//     }
//   }
// }
void CellList::update(std::span<Atom> atoms) {
  clear_cells();

  for (Atom &atom : atoms) {
    Vec3 frac_pos = m_unit_cell.to_fractional(atom.position());
    size_t ind_a = static_cast<int>(frac_pos.x() * m_params.a);
    size_t ind_b = static_cast<int>(frac_pos.y() * m_params.b);
    size_t ind_c = static_cast<int>(frac_pos.z() * m_params.c);

    // Use the coordinate map to get the cell index
    CellIndex coords{ind_a + m_params.num_ghosts, ind_b + m_params.num_ghosts,
                     ind_c + m_params.num_ghosts};
    std::cout << "aa" << std::endl;
    size_t cell_idx = get_index_from_coords(coords);
    std::cout << "bb: " << cell_idx << std::endl;
    std::cout << "m_cells: " << m_params.total_cells << std::endl;
    m_cells[cell_idx].add_atom(atom);
    std::cout << "cc" << std::endl;

    // Handle ghost cells...
    if (ind_a >= m_params.num_ghosts && ind_a < m_params.a_upper &&
        ind_b >= m_params.num_ghosts && ind_b < m_params.b_upper &&
        ind_c >= m_params.num_ghosts && ind_c < m_params.c_upper) {
      continue;
    }

    int a = (ind_a < m_params.num_ghosts)
                ? 1
                : (ind_a >= m_params.a_upper ? -1 : 0);
    int b = (ind_b < m_params.num_ghosts)
                ? 1
                : (ind_b >= m_params.b_upper ? -1 : 0);
    int c = (ind_c < m_params.num_ghosts)
                ? 1
                : (ind_c >= m_params.c_upper ? -1 : 0);

    for (int ia = 0; ia <= std::abs(a); ia++) {
      for (int ib = 0; ib <= std::abs(b); ib++) {
        for (int ic = 0; ic <= std::abs(c); ic++) {
          if (ia == 0 && ib == 0 && ic == 0) {
            continue;
          }
          int a_shift = ia * a, b_shift = ib * b, c_shift = ic * c;
          Vec3 shift = m_unit_cell.direct() * Vec3(a_shift, b_shift, c_shift);

          CellIndex ghost_coords{
              ind_a + a_shift * static_cast<int>(m_params.a) +
                  static_cast<int>(m_params.num_ghosts),
              ind_b + b_shift * static_cast<int>(m_params.b) +
                  static_cast<int>(m_params.num_ghosts),
              ind_c + c_shift * static_cast<int>(m_params.c) +
                  static_cast<int>(m_params.num_ghosts)};

          size_t ghost_idx = get_index_from_coords(ghost_coords);
          m_cells[ghost_idx].m_atoms.emplace_back(atom.create_ghost(shift));
        }
      }
    }
  }
}
} // namespace trajan::core
// tests
#include <catch2/benchmark/catch_benchmark.hpp>
#include <catch2/catch_test_macros.hpp>
#include <catch2/generators/catch_generators.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>
#include <chrono>
#include <iostream>
#include <omp.h>
#include <random>
#include <trajan/core/element.h>
#include <trajan/core/linear_algebra.h>
#include <trajan/core/neigh.h>
#include <trajan/core/unit_cell.h>
#include <trajan/core/units.h>
#include <vector>

using trajan::Mat3;
using trajan::Vec3;
using trajan::core::Atom;
using trajan::core::Cell;
using trajan::core::CellList;
using trajan::core::Element;
using trajan::core::UnitCell;

namespace units = trajan::units;

TEST_CASE("Element constructor with exact matching", "[element]") {
  SECTION("Exact matches are found correctly") {
    auto [input, expected_symbol, expected_number] =
        GENERATE(table<std::string, std::string, int>({{"H", "H", 1},
                                                       {"He", "He", 2},
                                                       {"Fe", "Fe", 26},
                                                       {"Au", "Au", 79},
                                                       {"U", "U", 92}}));

    Element e(input, true);
    REQUIRE(e.symbol() == expected_symbol);
    REQUIRE(e.atomic_number() == expected_number);
  }

  SECTION("Case sensitivity for exact matches") {
    auto [input, expected_symbol] = GENERATE(table<std::string, std::string>(
        {{"h", "Xx"}, {"HE", "Xx"}, {"fe", "Xx"}, {"AU", "Xx"}}));

    Element e(input, true);
    REQUIRE(e.symbol() == expected_symbol);
  }
}

TEST_CASE("Element constructor with partial matching", "[element]") {
  SECTION("Partial matches find longest valid symbol") {
    auto [input, expected_symbol] =
        GENERATE(table<std::string, std::string>({{"Hg", "Hg"},
                                                  {"Hge", "Hg"},
                                                  {"Her", "He"},
                                                  {"Fer", "Fe"},
                                                  {"Feat", "Fe"}}));

    Element e(input, false);
    REQUIRE(e.symbol() == expected_symbol);
  }

  SECTION("No match returns dummy element") {
    auto input = GENERATE("Q", "J", "X", "Qq", "Jk", "Xyz");

    Element e(input, false);
    REQUIRE(e.symbol() == "Xx");
    REQUIRE(e.atomic_number() == 0);
  }
}

TEST_CASE("Element constructor with edge cases", "[element]") {
  SECTION("Empty string returns dummy element") {
    Element e("", false);
    REQUIRE(e.symbol() == "Xx");
  }

  SECTION("Single character matches") {
    auto [input, expected_symbol] = GENERATE(table<std::string, std::string>(
        {{"H", "H"}, {"N", "N"}, {"O", "O"}, {"F", "F"}, {"U", "U"}}));

    Element e(input, false);
    REQUIRE(e.symbol() == expected_symbol);
  }
}

// Helper function to create a cubic unit cell
UnitCell create_cubic_cell(double length = 10.0) {
  Mat3 lattice;
  lattice << length, 0.0, 0.0, 0.0, length, 0.0, 0.0, 0.0, length;
  return UnitCell(lattice);
}

// Helper function to generate random atoms within a unit cell
std::vector<Atom> generate_random_atoms(const UnitCell &cell, int num_atoms) {
  std::vector<Atom> atoms;
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_real_distribution<> dis(0.0, 1.0);

  for (int i = 0; i < num_atoms; ++i) {
    Vec3 position(dis(gen), dis(gen), dis(gen));
    position = cell.to_cartesian(position);
    atoms.emplace_back(position, 0, i);
  }
  return atoms;
}

TEST_CASE("CellList Basic Construction", "[cell_list]") {
  auto unit_cell = create_cubic_cell(10.0);
  double cutoff = 2.0;

  SECTION("Construction with single thread") {
    REQUIRE_NOTHROW(CellList(unit_cell, cutoff, 1));
  }

  SECTION("Construction with multiple threads") {
    REQUIRE_NOTHROW(CellList(unit_cell, cutoff, 4));
  }

  SECTION("Construction with invalid thread count") {
    REQUIRE_NOTHROW(CellList(unit_cell, cutoff, -1));
  }
}

TEST_CASE("Cell Adding and Retrieving Atoms", "[cell]") {
  Cell cell;
  Vec3 pos(1.0, 1.0, 1.0);
  Atom atom(pos, 0, 0);

  SECTION("Adding single atom") {
    cell.add_atom(atom);
    REQUIRE(cell.get_atoms().size() == 1);
    REQUIRE(cell.get_atoms()[0].position() == pos);
  }

  SECTION("Adding multiple atoms") {
    const int num_atoms = 10;
    std::vector<Atom> atoms;
    for (int i = 0; i < num_atoms; ++i) {
      atoms.emplace_back(Vec3(i, i, i), 0, i);
      cell.add_atom(atoms.back());
    }
    REQUIRE(cell.get_atoms().size() == num_atoms);
  }
}

// helper function to measure execution time
template <typename Func> double measure_execution_time(Func &&func) {
  auto start = std::chrono::high_resolution_clock::now();
  func();
  auto end = std::chrono::high_resolution_clock::now();
  return std::chrono::duration<double>(end - start).count();
}

TEST_CASE("CellList vs Double Loop Comparison", "[cell_list]") {
  const double box_size = 25.0;
  UnitCell unit_cell = trajan::core::cubic_cell(box_size);
  const int num_atoms = 5000;
  const double cutoff = 9.0;
  const int num_threads = 1;
  std::vector<Atom> atoms;
  atoms.reserve(num_atoms);
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_real_distribution<> dis(0.0, box_size);

  // create atoms with random positions
  for (int i = 0; i < num_atoms; ++i) {
    Vec3 position(dis(gen), dis(gen), dis(gen));
    atoms.emplace_back(position, 0, i);
  }

  SECTION("Comparing pair counting between methods") {
    std::atomic<size_t> cell_list_pairs{0};
    std::atomic<size_t> double_loop_pairs{0};

    // count pairs using cell list
    std::cout << "hh" << std::endl;
    CellList cell_list(unit_cell, cutoff, num_threads);
    std::cout << "hj" << std::endl;
    double cell_list_time = measure_execution_time([&]() {
      std::cout << "here0" << std::endl;
      cell_list.update(atoms);
      std::cout << "here1" << std::endl;
      cell_list.for_each_pair(
          [&](const Atom &a1, const Atom &a2) { cell_list_pairs++; });
    });

    // count pairs using double loop
    double double_loop_time = measure_execution_time([&]() {
      for (size_t i = 0; i < atoms.size(); ++i) {
        for (size_t j = i + 1; j < atoms.size(); ++j) {
          Vec3 dr = atoms[j].position() - atoms[i].position();
          Vec3 frac_dr = unit_cell.to_fractional(dr);
          frac_dr = frac_dr.array() - frac_dr.array().round();
          dr = unit_cell.to_cartesian(frac_dr);

          if (dr.norm() <= cutoff) {
            double_loop_pairs++;
          }
        }
      }
    });

    INFO("System size: " << num_atoms << " atoms");
    INFO("Box size: " << box_size << "x" << box_size << "x" << box_size);
    INFO("Cutoff distance: " << cutoff);
    INFO("Number of threads: " << num_threads);

    // estimate the expected number of pairs
    double volume = box_size * box_size * box_size;
    double expected_pairs_per_atom =
        (4.0 / 3.0) * units::PI * std::pow(cutoff, 3) / volume * num_atoms;
    double total_expected_pairs = expected_pairs_per_atom * num_atoms / 2;
    INFO("Expected approximate number of pairs: ~" << total_expected_pairs);
    INFO("Pairs found (cell list): " << cell_list_pairs);
    INFO("Pairs found (double loop): " << double_loop_pairs);

    // Verify that both methods find the same number of pairs
    REQUIRE(cell_list_pairs == double_loop_pairs);
    REQUIRE(static_cast<double>(cell_list_pairs) > total_expected_pairs * 0.8);
    REQUIRE(static_cast<double>(cell_list_pairs) < total_expected_pairs * 1.2);
    INFO("Cell list execution time: " << cell_list_time << " seconds");
    INFO("Double loop execution time: " << double_loop_time << " seconds");
    INFO("Speed-up factor: " << double_loop_time / cell_list_time);

    // cell list should be faster
    REQUIRE(double_loop_time > cell_list_time);

    // for this system size, we expect at least a 10x speedup
    // NOTE: actual speedup depends on hardware and implementation details
    // INFO("Minimum expected speedup: 10x");
    // INFO("Actual speedup: " << double_loop_time / cell_list_time);
    // REQUIRE(double_loop_time / cell_list_time > 10.0);
  }
}

// TEST_CASE("CellList Performance", "[cell_list_performance]") {
//   const double box_size = 25.0;
//   const double cutoff = 9.0;
//   const int num_atoms = 5000;
//
//   // Create unit cell and atoms
//   UnitCell unit_cell = trajan::core::cubic_cell(box_size);
//   std::vector<Atom> atoms;
//   atoms.reserve(num_atoms);
//
//   // Create deterministic random number generator for reproducible tests
//   std::mt19937 gen(42);
//   std::uniform_real_distribution<> dis(0.0, box_size);
//
//   for (int i = 0; i < num_atoms; ++i) {
//     Vec3 position(dis(gen), dis(gen), dis(gen));
//     atoms.emplace_back(position, 0, i);
//   }
//
//   SECTION("Correctness Test") {
//     // Create two cell lists with different thread counts
//     CellList cell_list_single(unit_cell, cutoff, 1);
//     CellList cell_list_multi(unit_cell, cutoff, 4);
//
//     // Update both cell lists
//     cell_list_single.update(atoms);
//     cell_list_multi.update(atoms);
//
//     // Count pairs in both cell lists
//     std::atomic<size_t> pairs_single{0};
//     std::atomic<size_t> pairs_multi{0};
//     std::vector<std::pair<int, int>> pair_indices_single;
//     std::vector<std::pair<int, int>> pair_indices_multi;
//
//     cell_list_single.for_each_pair([&](const Atom &a1, const Atom &a2) {
//       pairs_single++;
//       pair_indices_single.emplace_back(a1.id(), a2.id());
//     });
//
//     cell_list_multi.for_each_pair([&](const Atom &a1, const Atom &a2) {
//       pairs_multi++;
//       pair_indices_multi.emplace_back(a1.id(), a2.id());
//     });
//
//     // Sort pair indices for comparison
//     std::sort(pair_indices_single.begin(), pair_indices_single.end());
//     std::sort(pair_indices_multi.begin(), pair_indices_multi.end());
//
//     // Verify results are identical
//     REQUIRE(pairs_single == pairs_multi);
//     REQUIRE(pair_indices_single == pair_indices_multi);
//   }
//
//   // SECTION("Performance Test") {
//   //   const int num_runs = 5;
//   //   std::vector<double> single_thread_times;
//   //   std::vector<double> multi_thread_times;
//   //
//   //   CellList cell_list_single(unit_cell, cutoff, 1);
//   //   CellList cell_list_multi(unit_cell, cutoff, 4);
//   //
//   //   for (int i = 0; i < num_runs; ++i) {
//   //     // Measure single-threaded performance
//   //     auto start_single = std::chrono::high_resolution_clock::now();
//   //     cell_list_single.update(atoms);
//   //     auto end_single = std::chrono::high_resolution_clock::now();
//   //     single_thread_times.push_back(
//   //         std::chrono::duration<double>(end_single -
//   start_single).count());
//   //
//   //     // Measure multi-threaded performance
//   //     auto start_multi = std::chrono::high_resolution_clock::now();
//   //     cell_list_multi.update(atoms);
//   //     auto end_multi = std::chrono::high_resolution_clock::now();
//   //     multi_thread_times.push_back(
//   //         std::chrono::duration<double>(end_multi - start_multi).count());
//   //   }
//   //
//   //   // Calculate average times
//   //   double avg_single = std::accumulate(single_thread_times.begin(),
//   //                                       single_thread_times.end(), 0.0) /
//   //                       num_runs;
//   //   double avg_multi = std::accumulate(multi_thread_times.begin(),
//   //                                      multi_thread_times.end(), 0.0) /
//   //                      num_runs;
//   //
//   //   // Verify multi-threaded version is faster
//   //   INFO("Average single-threaded time: " << avg_single << " seconds");
//   //   INFO("Average multi-threaded time: " << avg_multi << " seconds");
//   //   INFO("Speedup factor: " << avg_single / avg_multi);
//   //
//   //   REQUIRE(avg_multi < avg_single);
//   // }
// }
